#!/usr/bin/env python3
"""Dynamic DNS updater: Unifi Cloud Gateway Max → Porkbun.

Reads WAN IP from the local Unifi Network Application, compares it against the
cached value and the live Porkbun A record, and updates the record only when
the IP has actually changed.  In steady state (no IP change) the script makes
zero external API calls beyond reading the local cache file.

Logs to syslog (journald); view with: journalctl -t dynamic_dns
"""

import ipaddress
import logging
import logging.handlers
import sys
from pathlib import Path

import requests
import urllib3

# ── Configuration (injected by Ansible at deploy time) ───────────────────────
PORKBUN_API_KEY    = "{{ porkbun_api_key }}"
PORKBUN_SECRET_KEY = "{{ porkbun_api_key_secret }}"
DOMAIN             = "{{ homelab_domain }}"
SUBDOMAIN          = "{{ homelab_subdomain }}"
UNIFI_HOST         = "{{ unifi_host }}"
UNIFI_API_KEY      = "{{ unifi_api_key }}"
UNIFI_SITE         = "{{ unifi_site_id | default('default') }}"
IP_CACHE           = Path("/var/cache/dynamic_dns_ip")
PORKBUN_BASE       = "https://api.porkbun.com/api/json/v3"
TIMEOUT            = 10  # seconds per request

# ── Logging ───────────────────────────────────────────────────────────────────
log = logging.getLogger("dynamic_dns")
log.setLevel(logging.INFO)
try:
    _handler: logging.Handler = logging.handlers.SysLogHandler(
        address="/dev/log", facility=logging.handlers.SysLogHandler.LOG_DAEMON
    )
    _handler.ident = "dynamic_dns"
except OSError:
    _handler = logging.StreamHandler()
log.addHandler(_handler)


# ── Unifi ─────────────────────────────────────────────────────────────────────

def get_wan_ip() -> str:
    """Return the current WAN IP from the Unifi integration API.

    The UCG-Max serves its local API over HTTPS with a self-signed / Unifi-CA
    certificate.  SSL verification is disabled only for this LAN-local session;
    all outbound Porkbun calls use the default trusted CA bundle.

    The integration API wans endpoint typically returns ipAddress in the data
    array.  A fallback key 'ip' is checked in case the field name differs on
    some firmware versions.  If neither field is present, run:

        curl -sk -H 'X-API-KEY: <key>' \\
          https://<ucg-ip>/proxy/network/integration/v1/sites/default/wans \\
          | python3 -m json.tool

    to inspect the live response and adjust the key names below.
    """
    url = (
        f"https://{UNIFI_HOST}/proxy/network/integration/v1"
        f"/sites/{UNIFI_SITE}/wans"
    )
    urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
    session = requests.Session()
    session.verify = False
    session.headers["X-API-KEY"] = UNIFI_API_KEY

    resp = session.get(url, timeout=TIMEOUT)
    resp.raise_for_status()

    data = resp.json().get("data", [])
    if not data:
        raise ValueError("Unifi wans response contained no data entries")

    wan_ip = data[0].get("ipAddress") or data[0].get("ip")
    if not wan_ip:
        raise ValueError(f"WAN IP field not found in Unifi response: {data[0]}")

    addr = ipaddress.ip_address(wan_ip)
    if not isinstance(addr, ipaddress.IPv4Address) or not addr.is_global:
        raise ValueError(f"WAN IP {wan_ip!r} is not a global IPv4 address")

    return wan_ip


# ── Cache ─────────────────────────────────────────────────────────────────────

def get_cached_ip() -> str | None:
    """Return the last successfully applied IP, or None if not cached."""
    try:
        return IP_CACHE.read_text().strip() or None
    except FileNotFoundError:
        return None


# ── Porkbun ───────────────────────────────────────────────────────────────────

def _porkbun_post(endpoint: str, extra: dict) -> dict:
    payload = {
        "apikey": PORKBUN_API_KEY,
        "secretapikey": PORKBUN_SECRET_KEY,
        **extra,
    }
    resp = requests.post(
        f"{PORKBUN_BASE}/{endpoint}",
        json=payload,
        timeout=TIMEOUT,
    )
    resp.raise_for_status()
    result = resp.json()
    if result.get("status") != "SUCCESS":
        raise RuntimeError(
            f"Porkbun {endpoint!r} returned status "
            f"{result.get('status')!r}: {result.get('message', '')}"
        )
    return result


def get_dns_record() -> tuple[str | None, str | None]:
    """Return (current_ip, record_id) for the subdomain A record.

    Returns (None, None) if no record exists yet.
    """
    result = _porkbun_post(
        f"dns/retrieveByNameType/{DOMAIN}/A/{SUBDOMAIN}", {}
    )
    records = result.get("records", [])
    if not records:
        return None, None
    return records[0].get("content"), records[0].get("id")


def update_dns_record(record_id: str | None, new_ip: str) -> None:
    """Edit the existing A record, or create one if none exists."""
    if record_id:
        _porkbun_post(
            f"dns/edit/{DOMAIN}/{record_id}",
            {"content": new_ip, "ttl": "300"},
        )
    else:
        _porkbun_post(
            f"dns/create/{DOMAIN}",
            {"name": SUBDOMAIN, "type": "A", "content": new_ip, "ttl": "300"},
        )


# ── Entrypoint ────────────────────────────────────────────────────────────────

def main() -> int:
    try:
        wan_ip = get_wan_ip()
    except Exception as exc:
        log.error("Failed to get WAN IP from Unifi: %s", exc)
        return 1

    # Fast path: no API calls needed when cached IP is current
    if get_cached_ip() == wan_ip:
        return 0

    try:
        current_ip, record_id = get_dns_record()
    except Exception as exc:
        log.error("Failed to retrieve DNS record from Porkbun: %s", exc)
        return 1

    if wan_ip == current_ip:
        IP_CACHE.write_text(wan_ip)
        return 0

    try:
        update_dns_record(record_id, wan_ip)
    except Exception as exc:
        log.error("Failed to update DNS record: %s", exc)
        return 1

    IP_CACHE.write_text(wan_ip)
    log.info(
        "Updated %s.%s → %s (was %s)",
        SUBDOMAIN, DOMAIN, wan_ip, current_ip or "none",
    )
    return 0


if __name__ == "__main__":
    sys.exit(main())
