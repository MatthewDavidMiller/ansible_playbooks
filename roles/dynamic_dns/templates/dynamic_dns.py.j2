#!/usr/bin/env python3
"""Dynamic DNS updater: Porkbun ping → Porkbun DNS.

Reads WAN IP from the Porkbun ping endpoint, compares it against the cached
value and the live Porkbun A record, and updates the record only when the IP
has actually changed.  In steady state (no IP change) the script makes zero
external API calls beyond reading the local cache file.

Logs to /var/log/dynamic_dns.log (rotated at 1 MB, 5 backups).
"""

import ipaddress
import logging
import logging.handlers
import sys
from pathlib import Path

import requests

# ── Configuration (injected by Ansible at deploy time) ───────────────────────
PORKBUN_API_KEY    = "{{ porkbun_api_key }}"
PORKBUN_SECRET_KEY = "{{ porkbun_api_key_secret }}"
DOMAIN             = "{{ homelab_domain }}"
SUBDOMAIN          = "{{ homelab_subdomain }}"
IP_CACHE           = Path("/var/cache/dynamic_dns_ip")
PORKBUN_BASE       = "https://api.porkbun.com/api/json/v3"
PORKBUN_IPV4_BASE  = "https://api-ipv4.porkbun.com/api/json/v3"
TIMEOUT            = 10  # seconds per request

# ── Logging ───────────────────────────────────────────────────────────────────
LOG_FILE = Path("/var/log/dynamic_dns.log")

log = logging.getLogger("dynamic_dns")
log.setLevel(logging.INFO)

_formatter = logging.Formatter(
    fmt="%(asctime)s %(levelname)-8s %(message)s",
    datefmt="%Y-%m-%d %H:%M:%S",
)

try:
    _file_handler = logging.handlers.RotatingFileHandler(
        LOG_FILE, maxBytes=1 * 1024 * 1024, backupCount=5, encoding="utf-8"
    )
    _file_handler.setFormatter(_formatter)
    log.addHandler(_file_handler)
except OSError as _e:
    logging.basicConfig(stream=sys.stderr, level=logging.INFO)
    log.warning("Could not open log file %s: %s — falling back to stderr", LOG_FILE, _e)

# Always echo to stderr so manual runs and cron output are visible
_stderr_handler = logging.StreamHandler(sys.stderr)
_stderr_handler.setFormatter(_formatter)
log.addHandler(_stderr_handler)


def _log_unhandled(exc_type, exc_value, exc_tb):
    log.error("Unhandled exception", exc_info=(exc_type, exc_value, exc_tb))


sys.excepthook = _log_unhandled


# ── WAN IP ────────────────────────────────────────────────────────────────────

def get_wan_ip() -> str:
    """Return the current WAN IPv4 address via the Porkbun ping endpoint.

    Uses api-ipv4.porkbun.com to guarantee an IPv4 response regardless of
    whether the host has a dual-stack connection.
    """
    result = _porkbun_post("ping", {}, base=PORKBUN_IPV4_BASE)
    ip_str = result.get("yourIp")
    if not ip_str:
        raise ValueError(f"Porkbun ping response missing 'yourIp' field: {result}")
    addr = ipaddress.ip_address(ip_str)
    if not isinstance(addr, ipaddress.IPv4Address) or not addr.is_global:
        raise ValueError(f"WAN IP {ip_str!r} is not a global IPv4 address")
    return ip_str


# ── Cache ─────────────────────────────────────────────────────────────────────

def get_cached_ip() -> str | None:
    """Return the last successfully applied IP, or None if not cached."""
    try:
        return IP_CACHE.read_text().strip() or None
    except FileNotFoundError:
        return None


# ── Porkbun ───────────────────────────────────────────────────────────────────

def _porkbun_post(endpoint: str, extra: dict, base: str = PORKBUN_BASE) -> dict:
    payload = {
        "apikey": PORKBUN_API_KEY,
        "secretapikey": PORKBUN_SECRET_KEY,
        **extra,
    }
    resp = requests.post(
        f"{base}/{endpoint}",
        json=payload,
        timeout=TIMEOUT,
    )
    resp.raise_for_status()
    result = resp.json()
    if result.get("status") != "SUCCESS":
        raise RuntimeError(
            f"Porkbun {endpoint!r} returned status "
            f"{result.get('status')!r}: {result.get('message', '')}"
        )
    return result


def get_dns_record() -> tuple[str | None, str | None]:
    """Return (current_ip, record_id) for the subdomain A record.

    Returns (None, None) if no record exists yet.
    """
    result = _porkbun_post(
        f"dns/retrieveByNameType/{DOMAIN}/A/{SUBDOMAIN}", {}
    )
    records = result.get("records", [])
    if not records:
        return None, None
    return records[0].get("content"), records[0].get("id")


def update_dns_record(record_id: str | None, new_ip: str) -> None:
    """Edit the existing A record, or create one if none exists."""
    if record_id:
        _porkbun_post(
            f"dns/edit/{DOMAIN}/{record_id}",
            {"content": new_ip, "ttl": "300"},
        )
    else:
        _porkbun_post(
            f"dns/create/{DOMAIN}",
            {"name": SUBDOMAIN, "type": "A", "content": new_ip, "ttl": "300"},
        )


# ── Entrypoint ────────────────────────────────────────────────────────────────

def main() -> int:
    try:
        wan_ip = get_wan_ip()
    except Exception as exc:
        log.error("Failed to get WAN IP from Porkbun ping: %s", exc)
        return 1

    # Fast path: no API calls needed when cached IP is current
    if get_cached_ip() == wan_ip:
        return 0

    try:
        current_ip, record_id = get_dns_record()
    except Exception as exc:
        log.error("Failed to retrieve DNS record from Porkbun: %s", exc)
        return 1

    if wan_ip == current_ip:
        IP_CACHE.write_text(wan_ip)
        return 0

    try:
        update_dns_record(record_id, wan_ip)
    except Exception as exc:
        log.error("Failed to update DNS record: %s", exc)
        return 1

    IP_CACHE.write_text(wan_ip)
    log.info(
        "Updated %s.%s → %s (was %s)",
        SUBDOMAIN, DOMAIN, wan_ip, current_ip or "none",
    )
    return 0


if __name__ == "__main__":
    sys.exit(main())
